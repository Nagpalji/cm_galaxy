{"ast":null,"code":"import _objectSpread from\"C:/Users/nsahi/OneDrive/Documents/cyber_media/cm_galaxy/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";// import mock from '../mock'\n// import jwt from 'jsonwebtoken'\n// import { Fragment, useState, useContext, useRef } from 'react'\n// // api url\n// const api_url = \"https://srvr1px.cyberads.io/cmgalaxy_users/?user_name=testing&password=Gemsbschool\"\n// // Defining async function\n// async function getapi(url) {\n//     // Storing response\n//     const response = await fetch(url)\n//     // Storing data in form of JSON\n//     const data1 = await response.json()\n//     console.log(data1)\n//     localStorage.setItem('userlogin', JSON.stringify(data1))\n// }\n// // Calling that async function\n// getapi(api_url)\n// // ! These two secrets shall be in .env file and not in any other file\n// const jwtConfig = {\n//   secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\n//   refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\n//   expireTime: '30m',\n//   refreshTokenExpireTime: '30m'\n// }\n// mock.onPost('/jwt/login').reply(request => {\n//   const { email, password } = JSON.parse(request.data)\n//   let error = {\n//     email: ['Something went wrong']\n//   }\n//   const user = data.users.find(u => u.email === email && u.password === password)\n//   if (user) {\n//     try {\n//       const accessToken = jwt.sign({ id: user.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\n//       const refreshToken = jwt.sign({ id: user.id }, jwtConfig.refreshTokenSecret, {\n//         expiresIn: jwtConfig.refreshTokenExpireTime\n//       })\n//       const userData = { ...user }\n//       delete userData.password\n//       const response = {\n//         userData,\n//         accessToken,\n//         refreshToken\n//       }\n//       return [200, response]\n//     } catch (e) {\n//       error = e\n//     }\n//   } else {\n//     error = {\n//       email: ['Email or Password is Invalid']\n//     }\n//   }\n//   return [400, { error }]\n// })\n// mock.onPost('/jwt/register').reply(request => {\n//   if (request.data.length > 0) {\n//     const { email, password, username } = JSON.parse(request.data)\n//     const data = JSON.parse(localStorage.getItem('userlogin'))\n//     const isEmailAlreadyInUse = data.users.find(user => user.email === email)\n//     const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\n//     const error = {\n//       email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\n//       username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\n//     }\n//     if (!error.username && !error.email) {\n//       const userData = {\n//         email,\n//         password,\n//         username,\n//         fullName: '',\n//         avatar: null,\n//         role: 'admin',\n//         ability: [\n//           {\n//             action: 'manage',\n//             subject: 'all'\n//           }\n//         ]\n//       }\n//       // Add user id\n//       const length = data.users.length\n//       let lastIndex = 0\n//       if (length) {\n//         lastIndex = data.users[length - 1].id\n//       }\n//       userData.id = lastIndex + 1\n//       data.users.push(userData)\n//       const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\n//       const user = Object.assign({}, userData)\n//       delete user['password']\n//       const response = { user, accessToken }\n//       return [200, response]\n//     } else {\n//       return [200, { error }]\n//     }\n//   }\n// })\n// mock.onPost('/jwt/refresh-token').reply(request => {\n//   const { refreshToken } = JSON.parse(request.data)\n//   try {\n//     const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\n//     const userData = { ...data.users.find(user => user.id === id) }\n//     const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\n//     const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\n//       expiresIn: jwtConfig.refreshTokenExpireTime\n//     })\n//     delete userData.password\n//     const response = {\n//       userData,\n//       accessToken: newAccessToken,\n//       refreshToken: newRefreshToken\n//     }\n//     return [200, response]\n//   } catch (e) {\n//     const error = 'Invalid refresh token'\n//     return [401, { error }]\n//   }\n// })\nimport mock from'../mock';import jwt from'jsonwebtoken';import{Fragment,useState,useContext,useRef}from'react';// api url\n//if (localStorage.getItem('userlogin') !== null) {\n//}\n//localStorage.setItem('accessToken', 'dd5f3089-40c3-403d-af14-d0c228b05cb4')\n//localStorage.setItem('refreshToken', '7c4c1c50-3230-45bf-9eae-c9b2e401c767')\n// ! These two secrets shall be in .env file and not in any other file\nvar jwtConfig={secret:'dd5f3089-40c3-403d-af14-d0c228b05cb4',refreshTokenSecret:'7c4c1c50-3230-45bf-9eae-c9b2e401c767',expireTime:'10m',refreshTokenExpireTime:'10m'};mock.onPost('/jwt/login').reply(function(request){var _JSON$parse=JSON.parse(request.data),email=_JSON$parse.email,password=_JSON$parse.password;var error={email:['Something went wrong']};//  const data = JSON.parse(localStorage.getItem('userlogin'))\nvar CryptoJS=require(\"crypto-js\");var data=JSON.parse(CryptoJS.AES.decrypt(localStorage.getItem('encrypteddata'),'encryptionkeysetbyyatinonsep2022').toString(CryptoJS.enc.Utf8));// alert(\"testing\")\nvar user=data.users.find(function(u){return u.email===email&&u.password===password;});if(user){try{var accessToken=jwt.sign({id:user.id},jwtConfig.secret,{expiresIn:jwtConfig.expireTime});var refreshToken=jwt.sign({id:user.id},jwtConfig.refreshTokenSecret,{expiresIn:jwtConfig.refreshTokenExpireTime});var userData=_objectSpread({},user);delete userData.password;var response={userData:userData,accessToken:accessToken,refreshToken:refreshToken};return[200,response];}catch(e){error=e;}}else{error={email:['Email or Password is Invalid']};}return[400,{error:error}];});mock.onPost('/jwt/register').reply(function(request){if(request.data.length>0){var _JSON$parse2=JSON.parse(request.data),email=_JSON$parse2.email,password=_JSON$parse2.password,username=_JSON$parse2.username;var isEmailAlreadyInUse=data.users.find(function(user){return user.email===email;});var isUsernameAlreadyInUse=data.users.find(function(user){return user.username===username;});var error={email:isEmailAlreadyInUse?'This email is already in use.':null,username:isUsernameAlreadyInUse?'This username is already in use.':null};if(!error.username&&!error.email){var userData={email:email,password:password,username:username,fullName:'',avatar:null,role:'admin',ability:[{action:'manage',subject:'all'}]};// Add user id\nvar length=data.users.length;var lastIndex=0;if(length){lastIndex=data.users[length-1].id;}userData.id=lastIndex+1;data.users.push(userData);var accessToken=jwt.sign({id:userData.id},jwtConfig.secret,{expiresIn:jwtConfig.expireTime});var user=Object.assign({},userData);delete user['password'];var response={user:user,accessToken:accessToken};return[200,response];}else{return[200,{error:error}];}}});mock.onPost('/jwt/refresh-token').reply(function(request){var _JSON$parse3=JSON.parse(request.data),refreshToken=_JSON$parse3.refreshToken;try{var _jwt$verify=jwt.verify(refreshToken,jwtConfig.refreshTokenSecret),id=_jwt$verify.id;var userData=_objectSpread({},data.users.find(function(user){return user.id===id;}));var newAccessToken=jwt.sign({id:userData.id},jwtConfig.secret,{expiresIn:jwtConfig.expiresIn});var newRefreshToken=jwt.sign({id:userData.id},jwtConfig.refreshTokenSecret,{expiresIn:jwtConfig.refreshTokenExpireTime});delete userData.password;var response={userData:userData,accessToken:newAccessToken,refreshToken:newRefreshToken};return[200,response];}catch(e){var error='Invalid refresh token';return[401,{error:error}];}});","map":{"version":3,"sources":["C:/Users/nsahi/OneDrive/Documents/cyber_media/cm_galaxy/src/@fake-db/jwt/index.js"],"names":["mock","jwt","Fragment","useState","useContext","useRef","jwtConfig","secret","refreshTokenSecret","expireTime","refreshTokenExpireTime","onPost","reply","request","JSON","parse","data","email","password","error","CryptoJS","require","AES","decrypt","localStorage","getItem","toString","enc","Utf8","user","users","find","u","accessToken","sign","id","expiresIn","refreshToken","userData","response","e","length","username","isEmailAlreadyInUse","isUsernameAlreadyInUse","fullName","avatar","role","ability","action","subject","lastIndex","push","Object","assign","verify","newAccessToken","newRefreshToken"],"mappings":"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","sourcesContent":["// import mock from '../mock'\r\n// import jwt from 'jsonwebtoken'\r\n// import { Fragment, useState, useContext, useRef } from 'react'\r\n// // api url\r\n// const api_url = \"https://srvr1px.cyberads.io/cmgalaxy_users/?user_name=testing&password=Gemsbschool\"\r\n  \r\n// // Defining async function\r\n// async function getapi(url) {\r\n    \r\n//     // Storing response\r\n//     const response = await fetch(url)\r\n//     // Storing data in form of JSON\r\n//     const data1 = await response.json()\r\n//     console.log(data1)\r\n//     localStorage.setItem('userlogin', JSON.stringify(data1))\r\n\r\n// }\r\n// // Calling that async function\r\n// getapi(api_url)\r\n\r\n// // ! These two secrets shall be in .env file and not in any other file\r\n// const jwtConfig = {\r\n//   secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\r\n//   refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\r\n//   expireTime: '30m',\r\n//   refreshTokenExpireTime: '30m'\r\n// }\r\n\r\n// mock.onPost('/jwt/login').reply(request => {\r\n//   const { email, password } = JSON.parse(request.data)\r\n\r\n//   let error = {\r\n//     email: ['Something went wrong']\r\n//   }\r\n\r\n//   const user = data.users.find(u => u.email === email && u.password === password)\r\n\r\n//   if (user) {\r\n//     try {\r\n//       const accessToken = jwt.sign({ id: user.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n//       const refreshToken = jwt.sign({ id: user.id }, jwtConfig.refreshTokenSecret, {\r\n//         expiresIn: jwtConfig.refreshTokenExpireTime\r\n//       })\r\n\r\n//       const userData = { ...user }\r\n\r\n//       delete userData.password\r\n\r\n//       const response = {\r\n//         userData,\r\n//         accessToken,\r\n//         refreshToken\r\n//       }\r\n\r\n//       return [200, response]\r\n//     } catch (e) {\r\n//       error = e\r\n//     }\r\n//   } else {\r\n//     error = {\r\n//       email: ['Email or Password is Invalid']\r\n//     }\r\n//   }\r\n\r\n//   return [400, { error }]\r\n// })\r\n\r\n// mock.onPost('/jwt/register').reply(request => {\r\n//   if (request.data.length > 0) {\r\n//     const { email, password, username } = JSON.parse(request.data)\r\n//     const data = JSON.parse(localStorage.getItem('userlogin'))\r\n//     const isEmailAlreadyInUse = data.users.find(user => user.email === email)\r\n//     const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\r\n//     const error = {\r\n//       email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\r\n//       username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\r\n//     }\r\n\r\n//     if (!error.username && !error.email) {\r\n//       const userData = {\r\n//         email,\r\n//         password,\r\n//         username,\r\n//         fullName: '',\r\n//         avatar: null,\r\n//         role: 'admin',\r\n//         ability: [\r\n//           {\r\n//             action: 'manage',\r\n//             subject: 'all'\r\n//           }\r\n//         ]\r\n//       }\r\n\r\n//       // Add user id\r\n//       const length = data.users.length\r\n//       let lastIndex = 0\r\n//       if (length) {\r\n//         lastIndex = data.users[length - 1].id\r\n//       }\r\n//       userData.id = lastIndex + 1\r\n\r\n//       data.users.push(userData)\r\n\r\n//       const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n\r\n//       const user = Object.assign({}, userData)\r\n//       delete user['password']\r\n//       const response = { user, accessToken }\r\n\r\n//       return [200, response]\r\n//     } else {\r\n//       return [200, { error }]\r\n//     }\r\n//   }\r\n// })\r\n\r\n// mock.onPost('/jwt/refresh-token').reply(request => {\r\n//   const { refreshToken } = JSON.parse(request.data)\r\n\r\n//   try {\r\n//     const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\r\n\r\n//     const userData = { ...data.users.find(user => user.id === id) }\r\n\r\n//     const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\r\n//     const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\r\n//       expiresIn: jwtConfig.refreshTokenExpireTime\r\n//     })\r\n\r\n//     delete userData.password\r\n//     const response = {\r\n//       userData,\r\n//       accessToken: newAccessToken,\r\n//       refreshToken: newRefreshToken\r\n//     }\r\n\r\n//     return [200, response]\r\n//   } catch (e) {\r\n//     const error = 'Invalid refresh token'\r\n//     return [401, { error }]\r\n//   }\r\n// })\r\nimport mock from '../mock'\r\nimport jwt from 'jsonwebtoken'\r\nimport { Fragment, useState, useContext, useRef } from 'react'\r\n\r\n// api url\r\n//if (localStorage.getItem('userlogin') !== null) {\r\n\r\n//}\r\n//localStorage.setItem('accessToken', 'dd5f3089-40c3-403d-af14-d0c228b05cb4')\r\n//localStorage.setItem('refreshToken', '7c4c1c50-3230-45bf-9eae-c9b2e401c767')\r\n// ! These two secrets shall be in .env file and not in any other file\r\nconst jwtConfig = {\r\n  secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\r\n  refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\r\n  expireTime: '10m',\r\n  refreshTokenExpireTime: '10m'\r\n}\r\n\r\nmock.onPost('/jwt/login').reply(request => {\r\n  const { email, password } = JSON.parse(request.data)\r\n\r\n  let error = {\r\n    email: ['Something went wrong']\r\n  }\r\n\r\n//  const data = JSON.parse(localStorage.getItem('userlogin'))\r\nconst CryptoJS = require(\"crypto-js\")\r\n const data = JSON.parse((CryptoJS.AES.decrypt((localStorage.getItem('encrypteddata')), 'encryptionkeysetbyyatinonsep2022')).toString(CryptoJS.enc.Utf8))\r\n\r\n  // alert(\"testing\")\r\n  const user = data.users.find(u => u.email === email && u.password === password)\r\n\r\n  if (user) {\r\n    try {\r\n      const accessToken = jwt.sign({ id: user.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n      const refreshToken = jwt.sign({ id: user.id }, jwtConfig.refreshTokenSecret, {\r\n        expiresIn: jwtConfig.refreshTokenExpireTime\r\n      })\r\n\r\n      const userData = { ...user }\r\n\r\n      delete userData.password\r\n\r\n      const response = {\r\n        userData,\r\n        accessToken,\r\n        refreshToken\r\n      }\r\n\r\n      return [200, response]\r\n    } catch (e) {\r\n      error = e\r\n    }\r\n  } else {\r\n    error = {\r\n      email: ['Email or Password is Invalid']\r\n    }\r\n  }\r\n\r\n  return [400, { error }]\r\n})\r\n\r\nmock.onPost('/jwt/register').reply(request => {\r\n  if (request.data.length > 0) {\r\n    const { email, password, username } = JSON.parse(request.data)\r\n    const isEmailAlreadyInUse = data.users.find(user => user.email === email)\r\n    const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\r\n    const error = {\r\n      email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\r\n      username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\r\n    }\r\n\r\n    if (!error.username && !error.email) {\r\n      const userData = {\r\n        email,\r\n        password,\r\n        username,\r\n        fullName: '',\r\n        avatar: null,\r\n        role: 'admin',\r\n        ability: [\r\n          {\r\n            action: 'manage',\r\n            subject: 'all'\r\n          }\r\n        ]\r\n      }\r\n\r\n      // Add user id\r\n      const length = data.users.length\r\n      let lastIndex = 0\r\n      if (length) {\r\n        lastIndex = data.users[length - 1].id\r\n      }\r\n      userData.id = lastIndex + 1\r\n\r\n      data.users.push(userData)\r\n\r\n      const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n\r\n      const user = Object.assign({}, userData)\r\n      delete user['password']\r\n      const response = { user, accessToken }\r\n\r\n      return [200, response]\r\n    } else {\r\n      return [200, { error }]\r\n    }\r\n  }\r\n})\r\n\r\nmock.onPost('/jwt/refresh-token').reply(request => {\r\n  const { refreshToken } = JSON.parse(request.data)\r\n\r\n  try {\r\n    const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\r\n\r\n    const userData = { ...data.users.find(user => user.id === id) }\r\n\r\n    const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\r\n    const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\r\n      expiresIn: jwtConfig.refreshTokenExpireTime\r\n    })\r\n\r\n    delete userData.password\r\n    const response = {\r\n      userData,\r\n      accessToken: newAccessToken,\r\n      refreshToken: newRefreshToken\r\n    }\r\n\r\n    return [200, response]\r\n  } catch (e) {\r\n    const error = 'Invalid refresh token'\r\n    return [401, { error }]\r\n  }\r\n})\r\n"]},"metadata":{},"sourceType":"module"}