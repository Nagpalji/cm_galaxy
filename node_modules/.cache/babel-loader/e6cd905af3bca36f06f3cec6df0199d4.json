{"ast":null,"code":"import ErrorRangeCalculator from './error-bars/error-range-calculator';\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\nimport SeriesBinder from './series-binder';\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\nimport evalOptions from './utils/eval-options';\nimport categoriesCount from './utils/categories-count';\nimport { ChartElement, Box } from '../core';\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\n\nvar CategoricalChart = function (ChartElement) {\n  function CategoricalChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]); // Value axis ranges grouped by axis name, e.g.:\n    // primary: { min: 0, max: 1 }\n\n    this.valueAxisRanges = {};\n    this.points = [];\n    this.categoryPoints = [];\n    this.seriesPoints = [];\n    this.seriesOptions = [];\n    this._evalSeries = [];\n    this.render();\n  }\n\n  if (ChartElement) CategoricalChart.__proto__ = ChartElement;\n  CategoricalChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  CategoricalChart.prototype.constructor = CategoricalChart;\n\n  CategoricalChart.prototype.render = function render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  };\n\n  CategoricalChart.prototype.pointOptions = function pointOptions(series, seriesIx) {\n    var options = this.seriesOptions[seriesIx];\n\n    if (!options) {\n      var defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        vertical: !this.options.invertAxes\n      }, series);\n    }\n\n    return options;\n  };\n\n  CategoricalChart.prototype.plotValue = function plotValue(point) {\n    if (!point) {\n      return 0;\n    }\n\n    if (this.options.isStacked100 && isNumber(point.value)) {\n      var categoryIx = point.categoryIx;\n      var categoryPoints = this.categoryPoints[categoryIx];\n      var otherValues = [];\n      var categorySum = 0;\n\n      for (var i = 0; i < categoryPoints.length; i++) {\n        var other = categoryPoints[i];\n\n        if (other) {\n          var stack = point.series.stack;\n          var otherStack = other.series.stack;\n\n          if (stack && otherStack && stack.group !== otherStack.group) {\n            continue;\n          }\n\n          if (isNumber(other.value)) {\n            categorySum += Math.abs(other.value);\n            otherValues.push(Math.abs(other.value));\n          }\n        }\n      }\n\n      if (categorySum > 0) {\n        return point.value / categorySum;\n      }\n    }\n\n    return point.value;\n  };\n\n  CategoricalChart.prototype.plotRange = function plotRange(point, startValue) {\n    var this$1 = this;\n    if (startValue === void 0) startValue = 0;\n    var categoryPoints = this.categoryPoints[point.categoryIx];\n\n    if (this.options.isStacked) {\n      var plotValue = this.plotValue(point);\n      var positive = plotValue >= 0;\n      var prevValue = startValue;\n      var isStackedBar = false;\n\n      for (var i = 0; i < categoryPoints.length; i++) {\n        var other = categoryPoints[i];\n\n        if (point === other) {\n          break;\n        }\n\n        var stack = point.series.stack;\n        var otherStack = other.series.stack;\n\n        if (stack && otherStack) {\n          if (typeof stack === STRING && stack !== otherStack) {\n            continue;\n          }\n\n          if (stack.group && stack.group !== otherStack.group) {\n            continue;\n          }\n        }\n\n        var otherValue = this$1.plotValue(other);\n\n        if (otherValue >= 0 && positive || otherValue < 0 && !positive) {\n          prevValue += otherValue;\n          plotValue += otherValue;\n          isStackedBar = true;\n\n          if (this$1.options.isStacked100) {\n            plotValue = Math.min(plotValue, 1);\n          }\n        }\n      }\n\n      if (isStackedBar) {\n        prevValue -= startValue;\n      }\n\n      return [prevValue, plotValue];\n    }\n\n    var series = point.series;\n    var valueAxis = this.seriesValueAxis(series);\n    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];\n  };\n\n  CategoricalChart.prototype.stackLimits = function stackLimits(axisName, stackName) {\n    var this$1 = this;\n    var min = MAX_VALUE;\n    var max = MIN_VALUE;\n\n    for (var i = 0; i < this.categoryPoints.length; i++) {\n      var categoryPoints = this$1.categoryPoints[i];\n\n      if (!categoryPoints) {\n        continue;\n      }\n\n      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\n        var point = categoryPoints[pIx];\n\n        if (point) {\n          if (point.series.stack === stackName || point.series.axis === axisName) {\n            var to = this$1.plotRange(point, 0)[1];\n\n            if (defined(to) && isFinite(to)) {\n              max = Math.max(max, to);\n              min = Math.min(min, to);\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  CategoricalChart.prototype.updateStackRange = function updateStackRange() {\n    var this$1 = this;\n    var ref = this.options;\n    var isStacked = ref.isStacked;\n    var chartSeries = ref.series;\n    var limitsCache = {};\n\n    if (isStacked) {\n      for (var i = 0; i < chartSeries.length; i++) {\n        var series = chartSeries[i];\n        var axisName = series.axis;\n        var key = axisName + series.stack;\n        var limits = limitsCache[key];\n\n        if (!limits) {\n          limits = this$1.stackLimits(axisName, series.stack);\n          var errorTotals = this$1.errorTotals;\n\n          if (errorTotals) {\n            if (errorTotals.negative.length) {\n              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n            }\n\n            if (errorTotals.positive.length) {\n              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n            }\n          }\n\n          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n            limitsCache[key] = limits;\n          } else {\n            limits = null;\n          }\n        }\n\n        if (limits) {\n          this$1.valueAxisRanges[axisName] = limits;\n        }\n      }\n    }\n  };\n\n  CategoricalChart.prototype.addErrorBar = function addErrorBar(point, data, categoryIx) {\n    var value = point.value;\n    var series = point.series;\n    var seriesIx = point.seriesIx;\n    var errorBars = point.options.errorBars;\n    var lowValue = data.fields[ERROR_LOW_FIELD];\n    var highValue = data.fields[ERROR_HIGH_FIELD];\n    var errorRange;\n\n    if (isNumber(lowValue) && isNumber(highValue)) {\n      errorRange = {\n        low: lowValue,\n        high: highValue\n      };\n    } else if (errorBars && defined(errorBars.value)) {\n      this.seriesErrorRanges = this.seriesErrorRanges || [];\n      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new ErrorRangeCalculator(errorBars.value, series, VALUE);\n      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n    }\n\n    if (errorRange) {\n      point.low = errorRange.low;\n      point.high = errorRange.high;\n      this.addPointErrorBar(point, categoryIx);\n    }\n  };\n\n  CategoricalChart.prototype.addPointErrorBar = function addPointErrorBar(point, categoryIx) {\n    var isVertical = !this.options.invertAxes;\n    var options = point.options.errorBars;\n    var series = point.series;\n    var low = point.low;\n    var high = point.high;\n\n    if (this.options.isStacked) {\n      var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n      low = stackedErrorRange.low;\n      high = stackedErrorRange.high;\n    } else {\n      var fields = {\n        categoryIx: categoryIx,\n        series: series\n      };\n      this.updateRange({\n        value: low\n      }, fields);\n      this.updateRange({\n        value: high\n      }, fields);\n    }\n\n    var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n    point.errorBars = [errorBar];\n    point.append(errorBar);\n  };\n\n  CategoricalChart.prototype.stackedErrorRange = function stackedErrorRange(point, categoryIx) {\n    var plotValue = this.plotRange(point, 0)[1] - point.value;\n    var low = point.low + plotValue;\n    var high = point.high + plotValue;\n    this.errorTotals = this.errorTotals || {\n      positive: [],\n      negative: []\n    };\n\n    if (low < 0) {\n      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n    }\n\n    if (high > 0) {\n      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n    }\n\n    return {\n      low: low,\n      high: high\n    };\n  };\n\n  CategoricalChart.prototype.addValue = function addValue(data, fields) {\n    var categoryIx = fields.categoryIx;\n    var series = fields.series;\n    var seriesIx = fields.seriesIx;\n    var categoryPoints = this.categoryPoints[categoryIx];\n\n    if (!categoryPoints) {\n      this.categoryPoints[categoryIx] = categoryPoints = [];\n    }\n\n    var seriesPoints = this.seriesPoints[seriesIx];\n\n    if (!seriesPoints) {\n      this.seriesPoints[seriesIx] = seriesPoints = [];\n    }\n\n    var point = this.createPoint(data, fields);\n\n    if (point) {\n      Object.assign(point, fields);\n      point.owner = this;\n      point.noteText = data.fields.noteText;\n\n      if (!defined(point.dataItem)) {\n        point.dataItem = series.data[categoryIx];\n      }\n\n      this.addErrorBar(point, data, categoryIx);\n    }\n\n    this.points.push(point);\n    seriesPoints.push(point);\n    categoryPoints.push(point);\n    this.updateRange(data.valueFields, fields);\n  };\n\n  CategoricalChart.prototype.evalPointOptions = function evalPointOptions(options, value, category, categoryIx, series, seriesIx) {\n    var state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\"]\n    };\n    var doEval = this._evalSeries[seriesIx];\n\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n\n    var pointOptions = options;\n\n    if (doEval) {\n      pointOptions = deepExtend({}, pointOptions);\n      evalOptions(pointOptions, {\n        value: value,\n        category: category,\n        index: categoryIx,\n        series: series,\n        dataItem: series.data[categoryIx]\n      }, state);\n    }\n\n    return pointOptions;\n  };\n\n  CategoricalChart.prototype.updateRange = function updateRange(data, fields) {\n    var axisName = fields.series.axis;\n    var value = data.value;\n    var axisRange = this.valueAxisRanges[axisName];\n\n    if (isFinite(value) && value !== null) {\n      axisRange = this.valueAxisRanges[axisName] = axisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      axisRange.min = Math.min(axisRange.min, value);\n      axisRange.max = Math.max(axisRange.max, value);\n    }\n  };\n\n  CategoricalChart.prototype.seriesValueAxis = function seriesValueAxis(series) {\n    var plotArea = this.plotArea;\n    var axisName = series.axis;\n    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n    if (!axis) {\n      throw new Error(\"Unable to locate value axis with name \" + axisName);\n    }\n\n    return axis;\n  };\n\n  CategoricalChart.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    var categorySlots = this.categorySlots = [];\n    var chartPoints = this.points;\n    var categoryAxis = this.categoryAxis;\n    var pointIx = 0;\n    this.traverseDataPoints(function (data, fields) {\n      var categoryIx = fields.categoryIx;\n      var currentSeries = fields.series;\n      var valueAxis = this$1.seriesValueAxis(currentSeries);\n      var point = chartPoints[pointIx++];\n      var categorySlot = categorySlots[categoryIx];\n\n      if (!categorySlot) {\n        categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\n      }\n\n      if (point) {\n        var plotRange = this$1.plotRange(point, valueAxis.startValue());\n        var valueSlot = this$1.valueSlot(valueAxis, plotRange);\n\n        if (valueSlot) {\n          var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\n          point.aboveAxis = this$1.aboveAxis(point, valueAxis);\n          point.stackValue = plotRange[1];\n\n          if (this$1.options.isStacked100) {\n            point.percentage = this$1.plotValue(point);\n          }\n\n          this$1.reflowPoint(point, pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.reflowCategories(categorySlots);\n\n    if (!this.options.clip && this.options.limitPoints && this.points.length) {\n      this.limitPoints();\n    }\n\n    this.box = targetBox;\n  };\n\n  CategoricalChart.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {\n    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n  };\n\n  CategoricalChart.prototype.limitPoints = function limitPoints() {\n    var this$1 = this;\n    var categoryPoints = this.categoryPoints;\n    var points = categoryPoints[0].concat(last(categoryPoints));\n\n    for (var idx = 0; idx < points.length; idx++) {\n      if (points[idx]) {\n        this$1.limitPoint(points[idx]);\n      }\n    }\n  };\n\n  CategoricalChart.prototype.limitPoint = function limitPoint(point) {\n    var limittedSlot = this.categoryAxis.limitSlot(point.box);\n\n    if (!limittedSlot.equals(point.box)) {\n      point.reflow(limittedSlot);\n    }\n  };\n\n  CategoricalChart.prototype.aboveAxis = function aboveAxis(point, valueAxis) {\n    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    var value = point.value;\n    return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;\n  };\n\n  CategoricalChart.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {\n    var categoryAxis = this.categoryAxis;\n    var options = valueAxis.options;\n    var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    return crossingValues[categoryAxis.axisIndex || 0] || 0;\n  };\n\n  CategoricalChart.prototype.reflowPoint = function reflowPoint(point, pointSlot) {\n    point.reflow(pointSlot);\n  };\n\n  CategoricalChart.prototype.reflowCategories = function reflowCategories() {};\n\n  CategoricalChart.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {\n    var options = this.options;\n    var invertAxes = options.invertAxes;\n    var slotX = invertAxes ? valueSlot : categorySlot;\n    var slotY = invertAxes ? categorySlot : valueSlot;\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  };\n\n  CategoricalChart.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {\n    return categoryAxis.getSlot(categoryIx);\n  };\n\n  CategoricalChart.prototype.traverseDataPoints = function traverseDataPoints(callback) {\n    var this$1 = this;\n    var series = this.options.series;\n    var count = categoriesCount(series);\n    var seriesCount = series.length;\n\n    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      this$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n    }\n\n    for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\n        var currentSeries = series[seriesIx$1];\n        var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);\n\n        var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\n\n        callback(pointData, {\n          category: currentCategory,\n          categoryIx: categoryIx,\n          categoriesCount: count,\n          series: currentSeries,\n          seriesIx: seriesIx$1\n        });\n      }\n    }\n\n    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\n      this$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\n    }\n  };\n\n  CategoricalChart.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {\n    var outOfRangePoint = series[field];\n\n    if (outOfRangePoint) {\n      var categoryIx = outOfRangePoint.categoryIx;\n\n      var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n\n      callback(pointData, {\n        category: outOfRangePoint.category,\n        categoryIx: categoryIx,\n        series: series,\n        seriesIx: seriesIx,\n        dataItem: outOfRangePoint.item\n      });\n    }\n  };\n\n  CategoricalChart.prototype._bindPoint = function _bindPoint(series, seriesIx, categoryIx, item) {\n    if (!this._bindCache) {\n      this._bindCache = [];\n    }\n\n    var bindCache = this._bindCache[seriesIx];\n\n    if (!bindCache) {\n      bindCache = this._bindCache[seriesIx] = [];\n    }\n\n    var data = bindCache[categoryIx];\n\n    if (!data) {\n      data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\n    }\n\n    return data;\n  };\n\n  CategoricalChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    if (point.value === null) {\n      return \"\";\n    }\n\n    return this.chartService.format.auto(format, point.value);\n  };\n\n  CategoricalChart.prototype.pointValue = function pointValue(data) {\n    return data.valueFields.value;\n  };\n\n  return CategoricalChart;\n}(ChartElement);\n\nsetDefaultOptions(CategoricalChart, {\n  series: [],\n  invertAxes: false,\n  isStacked: false,\n  clip: true,\n  limitPoints: true\n});\nexport default CategoricalChart;","map":{"version":3,"sources":["C:/Users/nsahi/OneDrive/Documents/cyber_media/cm_galaxy/node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js"],"names":["ErrorRangeCalculator","CategoricalErrorBar","SeriesBinder","ERROR_LOW_FIELD","ERROR_HIGH_FIELD","evalOptions","categoriesCount","ChartElement","Box","VALUE","STRING","MIN_VALUE","MAX_VALUE","convertableToNumber","deepExtend","defined","isNumber","last","setDefaultOptions","sparseArrayLimits","CategoricalChart","plotArea","options","call","chartService","categoryAxis","seriesCategoryAxis","series","valueAxisRanges","points","categoryPoints","seriesPoints","seriesOptions","_evalSeries","render","__proto__","prototype","Object","create","constructor","traverseDataPoints","addValue","bind","pointOptions","seriesIx","defaults","pointType","vertical","invertAxes","plotValue","point","isStacked100","value","categoryIx","otherValues","categorySum","i","length","other","stack","otherStack","group","Math","abs","push","plotRange","startValue","this$1","isStacked","positive","prevValue","isStackedBar","otherValue","min","valueAxis","seriesValueAxis","axisCrossingValue","categoryAxisCrossingValue","stackLimits","axisName","stackName","max","pIx","axis","to","isFinite","updateStackRange","ref","chartSeries","limitsCache","key","limits","errorTotals","negative","addErrorBar","data","errorBars","lowValue","fields","highValue","errorRange","low","high","seriesErrorRanges","getErrorRange","addPointErrorBar","isVertical","stackedErrorRange","updateRange","errorBar","append","createPoint","assign","owner","noteText","dataItem","valueFields","evalPointOptions","category","state","_defaults","excluded","doEval","index","axisRange","namedValueAxes","Error","reflow","targetBox","categorySlots","chartPoints","pointIx","currentSeries","categorySlot","valueSlot","pointSlot","aboveAxis","stackValue","percentage","reflowPoint","visible","reflowCategories","clip","limitPoints","box","getSlot","concat","idx","limitPoint","limittedSlot","limitSlot","equals","reverse","crossingValues","axisCrossingValues","axisIndex","slotX","slotY","x1","y1","x2","y2","callback","count","seriesCount","_outOfRangeCallback","seriesIx$1","currentCategory","categoryAt","pointData","_bindPoint","seriesIx$2","field","outOfRangePoint","item","_bindCache","bindCache","current","bindPoint","formatPointValue","format","auto","pointValue"],"mappings":"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","sourcesContent":["import ErrorRangeCalculator from './error-bars/error-range-calculator';\r\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\r\n\r\nimport SeriesBinder from './series-binder';\r\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\r\n\r\nimport evalOptions from './utils/eval-options';\r\nimport categoriesCount from './utils/categories-count';\r\n\r\nimport { ChartElement, Box } from '../core';\r\n\r\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\r\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\r\n\r\nvar CategoricalChart = (function (ChartElement) {\r\n    function CategoricalChart(plotArea, options) {\r\n        ChartElement.call(this, options);\r\n\r\n        this.plotArea = plotArea;\r\n        this.chartService = plotArea.chartService;\r\n        this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\r\n\r\n        // Value axis ranges grouped by axis name, e.g.:\r\n        // primary: { min: 0, max: 1 }\r\n        this.valueAxisRanges = {};\r\n\r\n        this.points = [];\r\n        this.categoryPoints = [];\r\n        this.seriesPoints = [];\r\n        this.seriesOptions = [];\r\n        this._evalSeries = [];\r\n\r\n        this.render();\r\n    }\r\n\r\n    if ( ChartElement ) CategoricalChart.__proto__ = ChartElement;\r\n    CategoricalChart.prototype = Object.create( ChartElement && ChartElement.prototype );\r\n    CategoricalChart.prototype.constructor = CategoricalChart;\r\n\r\n    CategoricalChart.prototype.render = function render () {\r\n        this.traverseDataPoints(this.addValue.bind(this));\r\n    };\r\n\r\n    CategoricalChart.prototype.pointOptions = function pointOptions (series, seriesIx) {\r\n        var options = this.seriesOptions[seriesIx];\r\n        if (!options) {\r\n            var defaults = this.pointType().prototype.defaults;\r\n            this.seriesOptions[seriesIx] = options = deepExtend({ }, defaults, {\r\n                vertical: !this.options.invertAxes\r\n            }, series);\r\n        }\r\n\r\n        return options;\r\n    };\r\n\r\n    CategoricalChart.prototype.plotValue = function plotValue (point) {\r\n        if (!point) {\r\n            return 0;\r\n        }\r\n\r\n        if (this.options.isStacked100 && isNumber(point.value)) {\r\n            var categoryIx = point.categoryIx;\r\n            var categoryPoints = this.categoryPoints[categoryIx];\r\n            var otherValues = [];\r\n            var categorySum = 0;\r\n\r\n            for (var i = 0; i < categoryPoints.length; i++) {\r\n                var other = categoryPoints[i];\r\n                if (other) {\r\n                    var stack = point.series.stack;\r\n                    var otherStack = other.series.stack;\r\n\r\n                    if ((stack && otherStack) && stack.group !== otherStack.group) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (isNumber(other.value)) {\r\n                        categorySum += Math.abs(other.value);\r\n                        otherValues.push(Math.abs(other.value));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (categorySum > 0) {\r\n                return point.value / categorySum;\r\n            }\r\n        }\r\n\r\n        return point.value;\r\n    };\r\n\r\n    CategoricalChart.prototype.plotRange = function plotRange (point, startValue) {\r\n        var this$1 = this;\r\n        if ( startValue === void 0 ) startValue = 0;\r\n\r\n        var categoryPoints = this.categoryPoints[point.categoryIx];\r\n\r\n        if (this.options.isStacked) {\r\n            var plotValue = this.plotValue(point);\r\n            var positive = plotValue >= 0;\r\n            var prevValue = startValue;\r\n            var isStackedBar = false;\r\n\r\n            for (var i = 0; i < categoryPoints.length; i++) {\r\n                var other = categoryPoints[i];\r\n\r\n                if (point === other) {\r\n                    break;\r\n                }\r\n\r\n                var stack = point.series.stack;\r\n                var otherStack = other.series.stack;\r\n                if (stack && otherStack) {\r\n                    if (typeof stack === STRING && stack !== otherStack) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (stack.group && stack.group !== otherStack.group) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                var otherValue = this$1.plotValue(other);\r\n                if ((otherValue >= 0 && positive) ||\r\n                    (otherValue < 0 && !positive)) {\r\n                    prevValue += otherValue;\r\n                    plotValue += otherValue;\r\n                    isStackedBar = true;\r\n\r\n                    if (this$1.options.isStacked100) {\r\n                        plotValue = Math.min(plotValue, 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (isStackedBar) {\r\n                prevValue -= startValue;\r\n            }\r\n\r\n            return [ prevValue, plotValue ];\r\n        }\r\n\r\n        var series = point.series;\r\n        var valueAxis = this.seriesValueAxis(series);\r\n        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\r\n\r\n        return [ axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue ];\r\n    };\r\n\r\n    CategoricalChart.prototype.stackLimits = function stackLimits (axisName, stackName) {\r\n        var this$1 = this;\r\n\r\n        var min = MAX_VALUE;\r\n        var max = MIN_VALUE;\r\n\r\n        for (var i = 0; i < this.categoryPoints.length; i++) {\r\n            var categoryPoints = this$1.categoryPoints[i];\r\n            if (!categoryPoints) {\r\n                continue;\r\n            }\r\n\r\n            for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\r\n                var point = categoryPoints[pIx];\r\n                if (point) {\r\n                    if (point.series.stack === stackName || point.series.axis === axisName) {\r\n                        var to = this$1.plotRange(point, 0)[1];\r\n                        if (defined(to) && isFinite(to)) {\r\n                            max = Math.max(max, to);\r\n                            min = Math.min(min, to);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return { min: min, max: max };\r\n    };\r\n\r\n    CategoricalChart.prototype.updateStackRange = function updateStackRange () {\r\n        var this$1 = this;\r\n\r\n        var ref = this.options;\r\n        var isStacked = ref.isStacked;\r\n        var chartSeries = ref.series;\r\n        var limitsCache = {};\r\n\r\n        if (isStacked) {\r\n            for (var i = 0; i < chartSeries.length; i++) {\r\n                var series = chartSeries[i];\r\n                var axisName = series.axis;\r\n                var key = axisName + series.stack;\r\n\r\n                var limits = limitsCache[key];\r\n                if (!limits) {\r\n                    limits = this$1.stackLimits(axisName, series.stack);\r\n\r\n                    var errorTotals = this$1.errorTotals;\r\n                    if (errorTotals) {\r\n                        if (errorTotals.negative.length) {\r\n                            limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\r\n                        }\r\n                        if (errorTotals.positive.length) {\r\n                            limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\r\n                        }\r\n                    }\r\n\r\n                    if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\r\n                        limitsCache[key] = limits;\r\n                    } else {\r\n                        limits = null;\r\n                    }\r\n                }\r\n\r\n                if (limits) {\r\n                    this$1.valueAxisRanges[axisName] = limits;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    CategoricalChart.prototype.addErrorBar = function addErrorBar (point, data, categoryIx) {\r\n        var value = point.value;\r\n        var series = point.series;\r\n        var seriesIx = point.seriesIx;\r\n        var errorBars = point.options.errorBars;\r\n        var lowValue = data.fields[ERROR_LOW_FIELD];\r\n        var highValue = data.fields[ERROR_HIGH_FIELD];\r\n        var errorRange;\r\n\r\n        if (isNumber(lowValue) && isNumber(highValue)) {\r\n            errorRange = { low: lowValue, high: highValue };\r\n        } else if (errorBars && defined(errorBars.value)) {\r\n            this.seriesErrorRanges = this.seriesErrorRanges || [];\r\n            this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] ||\r\n                new ErrorRangeCalculator(errorBars.value, series, VALUE);\r\n\r\n            errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\r\n        }\r\n\r\n        if (errorRange) {\r\n            point.low = errorRange.low;\r\n            point.high = errorRange.high;\r\n            this.addPointErrorBar(point, categoryIx);\r\n        }\r\n    };\r\n\r\n    CategoricalChart.prototype.addPointErrorBar = function addPointErrorBar (point, categoryIx) {\r\n        var isVertical = !this.options.invertAxes;\r\n        var options = point.options.errorBars;\r\n        var series = point.series;\r\n        var low = point.low;\r\n        var high = point.high;\r\n\r\n        if (this.options.isStacked) {\r\n            var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\r\n            low = stackedErrorRange.low;\r\n            high = stackedErrorRange.high;\r\n        } else {\r\n            var fields = { categoryIx: categoryIx, series: series };\r\n            this.updateRange({ value: low }, fields);\r\n            this.updateRange({ value: high }, fields);\r\n        }\r\n\r\n        var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\r\n        point.errorBars = [ errorBar ];\r\n        point.append(errorBar);\r\n    };\r\n\r\n    CategoricalChart.prototype.stackedErrorRange = function stackedErrorRange (point, categoryIx) {\r\n        var plotValue = this.plotRange(point, 0)[1] - point.value;\r\n        var low = point.low + plotValue;\r\n        var high = point.high + plotValue;\r\n\r\n        this.errorTotals = this.errorTotals || { positive: [], negative: [] };\r\n\r\n        if (low < 0) {\r\n            this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\r\n        }\r\n\r\n        if (high > 0) {\r\n            this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\r\n        }\r\n\r\n        return { low: low, high: high };\r\n    };\r\n\r\n    CategoricalChart.prototype.addValue = function addValue (data, fields) {\r\n        var categoryIx = fields.categoryIx;\r\n        var series = fields.series;\r\n        var seriesIx = fields.seriesIx;\r\n\r\n        var categoryPoints = this.categoryPoints[categoryIx];\r\n        if (!categoryPoints) {\r\n            this.categoryPoints[categoryIx] = categoryPoints = [];\r\n        }\r\n\r\n        var seriesPoints = this.seriesPoints[seriesIx];\r\n        if (!seriesPoints) {\r\n            this.seriesPoints[seriesIx] = seriesPoints = [];\r\n        }\r\n\r\n        var point = this.createPoint(data, fields);\r\n        if (point) {\r\n            Object.assign(point, fields);\r\n\r\n            point.owner = this;\r\n            point.noteText = data.fields.noteText;\r\n            if (!defined(point.dataItem)) {\r\n                point.dataItem = series.data[categoryIx];\r\n            }\r\n            this.addErrorBar(point, data, categoryIx);\r\n        }\r\n\r\n        this.points.push(point);\r\n        seriesPoints.push(point);\r\n        categoryPoints.push(point);\r\n\r\n        this.updateRange(data.valueFields, fields);\r\n    };\r\n\r\n    CategoricalChart.prototype.evalPointOptions = function evalPointOptions (options, value, category, categoryIx, series, seriesIx) {\r\n        var state = { defaults: series._defaults, excluded: [ \"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\" ] };\r\n\r\n        var doEval = this._evalSeries[seriesIx];\r\n        if (!defined(doEval)) {\r\n            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\r\n        }\r\n\r\n        var pointOptions = options;\r\n        if (doEval) {\r\n            pointOptions = deepExtend({}, pointOptions);\r\n            evalOptions(pointOptions, {\r\n                value: value,\r\n                category: category,\r\n                index: categoryIx,\r\n                series: series,\r\n                dataItem: series.data[categoryIx]\r\n            }, state);\r\n        }\r\n\r\n        return pointOptions;\r\n    };\r\n\r\n    CategoricalChart.prototype.updateRange = function updateRange (data, fields) {\r\n        var axisName = fields.series.axis;\r\n        var value = data.value;\r\n        var axisRange = this.valueAxisRanges[axisName];\r\n\r\n        if (isFinite(value) && value !== null) {\r\n            axisRange = this.valueAxisRanges[axisName] =\r\n                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n            axisRange.min = Math.min(axisRange.min, value);\r\n            axisRange.max = Math.max(axisRange.max, value);\r\n        }\r\n    };\r\n\r\n    CategoricalChart.prototype.seriesValueAxis = function seriesValueAxis (series) {\r\n        var plotArea = this.plotArea;\r\n        var axisName = series.axis;\r\n        var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\r\n\r\n        if (!axis) {\r\n            throw new Error(\"Unable to locate value axis with name \" + axisName);\r\n        }\r\n\r\n        return axis;\r\n    };\r\n\r\n    CategoricalChart.prototype.reflow = function reflow (targetBox) {\r\n        var this$1 = this;\r\n\r\n        var categorySlots = this.categorySlots = [];\r\n        var chartPoints = this.points;\r\n        var categoryAxis = this.categoryAxis;\r\n        var pointIx = 0;\r\n\r\n        this.traverseDataPoints(function (data, fields) {\r\n            var categoryIx = fields.categoryIx;\r\n            var currentSeries = fields.series;\r\n\r\n            var valueAxis = this$1.seriesValueAxis(currentSeries);\r\n            var point = chartPoints[pointIx++];\r\n\r\n            var categorySlot = categorySlots[categoryIx];\r\n            if (!categorySlot) {\r\n                categorySlots[categoryIx] = categorySlot =\r\n                    this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\r\n            }\r\n\r\n            if (point) {\r\n                var plotRange = this$1.plotRange(point, valueAxis.startValue());\r\n                var valueSlot = this$1.valueSlot(valueAxis, plotRange);\r\n                if (valueSlot) {\r\n                    var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\r\n\r\n                    point.aboveAxis = this$1.aboveAxis(point, valueAxis);\r\n                    point.stackValue = plotRange[1];\r\n\r\n                    if (this$1.options.isStacked100) {\r\n                        point.percentage = this$1.plotValue(point);\r\n                    }\r\n\r\n                    this$1.reflowPoint(point, pointSlot);\r\n                } else {\r\n                    point.visible = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        this.reflowCategories(categorySlots);\r\n        if (!this.options.clip && this.options.limitPoints && this.points.length) {\r\n            this.limitPoints();\r\n        }\r\n\r\n        this.box = targetBox;\r\n    };\r\n\r\n    CategoricalChart.prototype.valueSlot = function valueSlot (valueAxis, plotRange) {\r\n        return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\r\n    };\r\n\r\n    CategoricalChart.prototype.limitPoints = function limitPoints () {\r\n        var this$1 = this;\r\n\r\n        var categoryPoints = this.categoryPoints;\r\n        var points = categoryPoints[0].concat(last(categoryPoints));\r\n        for (var idx = 0; idx < points.length; idx++) {\r\n            if (points[idx]) {\r\n                this$1.limitPoint(points[idx]);\r\n            }\r\n        }\r\n    };\r\n\r\n    CategoricalChart.prototype.limitPoint = function limitPoint (point) {\r\n        var limittedSlot = this.categoryAxis.limitSlot(point.box);\r\n        if (!limittedSlot.equals(point.box)) {\r\n            point.reflow(limittedSlot);\r\n        }\r\n    };\r\n\r\n    CategoricalChart.prototype.aboveAxis = function aboveAxis (point, valueAxis) {\r\n        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\r\n        var value = point.value;\r\n\r\n        return valueAxis.options.reverse ?\r\n            value < axisCrossingValue : value >= axisCrossingValue;\r\n    };\r\n\r\n    CategoricalChart.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue (valueAxis) {\r\n        var categoryAxis = this.categoryAxis;\r\n        var options = valueAxis.options;\r\n        var crossingValues = [].concat(\r\n            options.axisCrossingValues || options.axisCrossingValue\r\n        );\r\n\r\n        return crossingValues[categoryAxis.axisIndex || 0] || 0;\r\n    };\r\n\r\n    CategoricalChart.prototype.reflowPoint = function reflowPoint (point, pointSlot) {\r\n        point.reflow(pointSlot);\r\n    };\r\n\r\n    CategoricalChart.prototype.reflowCategories = function reflowCategories () { };\r\n\r\n    CategoricalChart.prototype.pointSlot = function pointSlot (categorySlot, valueSlot) {\r\n        var options = this.options;\r\n        var invertAxes = options.invertAxes;\r\n        var slotX = invertAxes ? valueSlot : categorySlot;\r\n        var slotY = invertAxes ? categorySlot : valueSlot;\r\n\r\n        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\r\n    };\r\n\r\n    CategoricalChart.prototype.categorySlot = function categorySlot (categoryAxis, categoryIx) {\r\n        return categoryAxis.getSlot(categoryIx);\r\n    };\r\n\r\n    CategoricalChart.prototype.traverseDataPoints = function traverseDataPoints (callback) {\r\n        var this$1 = this;\r\n\r\n        var series = this.options.series;\r\n        var count = categoriesCount(series);\r\n        var seriesCount = series.length;\r\n\r\n        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\r\n            this$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\r\n        }\r\n\r\n        for (var categoryIx = 0; categoryIx < count; categoryIx++) {\r\n            for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\r\n                var currentSeries = series[seriesIx$1];\r\n                var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);\r\n                var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\r\n\r\n                callback(pointData, {\r\n                    category: currentCategory,\r\n                    categoryIx: categoryIx,\r\n                    categoriesCount: count,\r\n                    series: currentSeries,\r\n                    seriesIx: seriesIx$1\r\n                });\r\n            }\r\n        }\r\n\r\n        for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\r\n            this$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\r\n        }\r\n    };\r\n\r\n    CategoricalChart.prototype._outOfRangeCallback = function _outOfRangeCallback (series, field, seriesIx, callback) {\r\n        var outOfRangePoint = series[field];\r\n        if (outOfRangePoint) {\r\n            var categoryIx = outOfRangePoint.categoryIx;\r\n            var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\r\n\r\n            callback(pointData, {\r\n                category: outOfRangePoint.category,\r\n                categoryIx: categoryIx,\r\n                series: series,\r\n                seriesIx: seriesIx,\r\n                dataItem: outOfRangePoint.item\r\n            });\r\n        }\r\n    };\r\n\r\n    CategoricalChart.prototype._bindPoint = function _bindPoint (series, seriesIx, categoryIx, item) {\r\n        if (!this._bindCache) {\r\n            this._bindCache = [];\r\n        }\r\n\r\n        var bindCache = this._bindCache[seriesIx];\r\n        if (!bindCache) {\r\n            bindCache = this._bindCache[seriesIx] = [];\r\n        }\r\n\r\n        var data = bindCache[categoryIx];\r\n        if (!data) {\r\n            data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\r\n        }\r\n\r\n        return data;\r\n    };\r\n\r\n    CategoricalChart.prototype.formatPointValue = function formatPointValue (point, format) {\r\n        if (point.value === null) {\r\n            return \"\";\r\n        }\r\n\r\n        return this.chartService.format.auto(format, point.value);\r\n    };\r\n\r\n    CategoricalChart.prototype.pointValue = function pointValue (data) {\r\n        return data.valueFields.value;\r\n    };\r\n\r\n    return CategoricalChart;\r\n}(ChartElement));\r\n\r\nsetDefaultOptions(CategoricalChart, {\r\n    series: [],\r\n    invertAxes: false,\r\n    isStacked: false,\r\n    clip: true,\r\n    limitPoints: true\r\n});\r\n\r\nexport default CategoricalChart;\r\n"]},"metadata":{},"sourceType":"module"}