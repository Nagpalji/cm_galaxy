{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport * as React from 'react';\n/**\r\n * An utility function for asynchronous focus/blur handling.\r\n *\r\n * By default, the `onFocus` and `onBlur` callbacks are called every time a child components receives/loses focus.\r\n * Use this utility hook for scenarios where you need to know if the parent has received focus for the first time, or completely lost focus.\r\n *\r\n * @returns\r\n */\n\nexport function useAsyncFocusBlur(_a) {\n  var onFocus = _a.onFocus,\n      onBlur = _a.onBlur,\n      onSyncFocus = _a.onSyncFocus,\n      onSyncBlur = _a.onSyncBlur;\n  var focused = React.useRef(false);\n  var tick = React.useRef(0);\n  var nextTick = React.useCallback(function (f) {\n    clearTimeout(tick.current);\n    tick.current = window.setTimeout(function () {\n      return f();\n    });\n  }, [tick]);\n  var handleFocus = React.useCallback(function () {\n    var event = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n\n    clearTimeout(tick.current);\n\n    if (onSyncFocus) {\n      onSyncFocus.call(undefined, event[0]);\n    }\n\n    if (focused.current) {\n      return;\n    }\n\n    ;\n    focused.current = true;\n\n    if (onFocus) {\n      onFocus.call.apply(onFocus, __spreadArray([undefined], event, false));\n    }\n  }, [focused, onFocus, onSyncFocus]);\n  var handleBlur = React.useCallback(function () {\n    var event = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n\n    if (onSyncBlur) {\n      onSyncBlur.call(undefined, event[0]);\n    }\n\n    nextTick(function () {\n      if (!focused.current) {\n        return;\n      }\n\n      if (onBlur) {\n        focused.current = false;\n        onBlur.call.apply(onBlur, __spreadArray([undefined], event, false));\n      }\n    });\n  }, [focused, nextTick, onBlur, onSyncBlur]);\n  React.useEffect(function () {\n    return function () {\n      clearTimeout(tick.current);\n    };\n  }, []);\n  return {\n    onFocus: handleFocus,\n    onBlur: handleBlur\n  };\n}","map":{"version":3,"sources":["C:/Users/nsahi/OneDrive/Documents/cyber_media/cm_galaxy/node_modules/@progress/kendo-react-common/dist/es/hooks/useAsyncFocusBlur.js"],"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","React","useAsyncFocusBlur","_a","onFocus","onBlur","onSyncFocus","onSyncBlur","focused","useRef","tick","nextTick","useCallback","f","clearTimeout","current","window","setTimeout","handleFocus","event","_i","undefined","apply","handleBlur","useEffect"],"mappings":"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","sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nimport * as React from 'react';\r\n/**\r\n * An utility function for asynchronous focus/blur handling.\r\n *\r\n * By default, the `onFocus` and `onBlur` callbacks are called every time a child components receives/loses focus.\r\n * Use this utility hook for scenarios where you need to know if the parent has received focus for the first time, or completely lost focus.\r\n *\r\n * @returns\r\n */\r\nexport function useAsyncFocusBlur(_a) {\r\n    var onFocus = _a.onFocus, onBlur = _a.onBlur, onSyncFocus = _a.onSyncFocus, onSyncBlur = _a.onSyncBlur;\r\n    var focused = React.useRef(false);\r\n    var tick = React.useRef(0);\r\n    var nextTick = React.useCallback(function (f) {\r\n        clearTimeout(tick.current);\r\n        tick.current = window.setTimeout(function () { return f(); });\r\n    }, [tick]);\r\n    var handleFocus = React.useCallback(function () {\r\n        var event = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            event[_i] = arguments[_i];\r\n        }\r\n        clearTimeout(tick.current);\r\n        if (onSyncFocus) {\r\n            onSyncFocus.call(undefined, event[0]);\r\n        }\r\n        if (focused.current) {\r\n            return;\r\n        }\r\n        ;\r\n        focused.current = true;\r\n        if (onFocus) {\r\n            onFocus.call.apply(onFocus, __spreadArray([undefined], event, false));\r\n        }\r\n    }, [focused, onFocus, onSyncFocus]);\r\n    var handleBlur = React.useCallback(function () {\r\n        var event = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            event[_i] = arguments[_i];\r\n        }\r\n        if (onSyncBlur) {\r\n            onSyncBlur.call(undefined, event[0]);\r\n        }\r\n        nextTick(function () {\r\n            if (!focused.current) {\r\n                return;\r\n            }\r\n            if (onBlur) {\r\n                focused.current = false;\r\n                onBlur.call.apply(onBlur, __spreadArray([undefined], event, false));\r\n            }\r\n        });\r\n    }, [focused, nextTick, onBlur, onSyncBlur]);\r\n    React.useEffect(function () {\r\n        return function () {\r\n            clearTimeout(tick.current);\r\n        };\r\n    }, []);\r\n    return {\r\n        onFocus: handleFocus,\r\n        onBlur: handleBlur\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}