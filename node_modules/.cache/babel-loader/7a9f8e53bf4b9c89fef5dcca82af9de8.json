{"ast":null,"code":"import _objectSpread from \"C:/Users/nsahi/OneDrive/Documents/cyber_media/full-version/full-version/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n// import mock from '../mock'\n// import jwt from 'jsonwebtoken'\n// import { Fragment, useState, useContext, useRef } from 'react'\n// // api url\n// const api_url = \"https://srvr1px.cyberads.io/cmgalaxy_users/?user_name=testing&password=Gemsbschool\"\n// // Defining async function\n// async function getapi(url) {\n//     // Storing response\n//     const response = await fetch(url)\n//     // Storing data in form of JSON\n//     const data1 = await response.json()\n//     console.log(data1)\n//     localStorage.setItem('userlogin', JSON.stringify(data1))\n// }\n// // Calling that async function\n// getapi(api_url)\n// // ! These two secrets shall be in .env file and not in any other file\n// const jwtConfig = {\n//   secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\n//   refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\n//   expireTime: '30m',\n//   refreshTokenExpireTime: '30m'\n// }\n// mock.onPost('/jwt/login').reply(request => {\n//   const { email, password } = JSON.parse(request.data)\n//   let error = {\n//     email: ['Something went wrong']\n//   }\n//   const user = data.users.find(u => u.email === email && u.password === password)\n//   if (user) {\n//     try {\n//       const accessToken = jwt.sign({ id: user.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\n//       const refreshToken = jwt.sign({ id: user.id }, jwtConfig.refreshTokenSecret, {\n//         expiresIn: jwtConfig.refreshTokenExpireTime\n//       })\n//       const userData = { ...user }\n//       delete userData.password\n//       const response = {\n//         userData,\n//         accessToken,\n//         refreshToken\n//       }\n//       return [200, response]\n//     } catch (e) {\n//       error = e\n//     }\n//   } else {\n//     error = {\n//       email: ['Email or Password is Invalid']\n//     }\n//   }\n//   return [400, { error }]\n// })\n// mock.onPost('/jwt/register').reply(request => {\n//   if (request.data.length > 0) {\n//     const { email, password, username } = JSON.parse(request.data)\n//     const data = JSON.parse(localStorage.getItem('userlogin'))\n//     const isEmailAlreadyInUse = data.users.find(user => user.email === email)\n//     const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\n//     const error = {\n//       email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\n//       username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\n//     }\n//     if (!error.username && !error.email) {\n//       const userData = {\n//         email,\n//         password,\n//         username,\n//         fullName: '',\n//         avatar: null,\n//         role: 'admin',\n//         ability: [\n//           {\n//             action: 'manage',\n//             subject: 'all'\n//           }\n//         ]\n//       }\n//       // Add user id\n//       const length = data.users.length\n//       let lastIndex = 0\n//       if (length) {\n//         lastIndex = data.users[length - 1].id\n//       }\n//       userData.id = lastIndex + 1\n//       data.users.push(userData)\n//       const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\n//       const user = Object.assign({}, userData)\n//       delete user['password']\n//       const response = { user, accessToken }\n//       return [200, response]\n//     } else {\n//       return [200, { error }]\n//     }\n//   }\n// })\n// mock.onPost('/jwt/refresh-token').reply(request => {\n//   const { refreshToken } = JSON.parse(request.data)\n//   try {\n//     const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\n//     const userData = { ...data.users.find(user => user.id === id) }\n//     const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\n//     const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\n//       expiresIn: jwtConfig.refreshTokenExpireTime\n//     })\n//     delete userData.password\n//     const response = {\n//       userData,\n//       accessToken: newAccessToken,\n//       refreshToken: newRefreshToken\n//     }\n//     return [200, response]\n//   } catch (e) {\n//     const error = 'Invalid refresh token'\n//     return [401, { error }]\n//   }\n// })\nimport mock from '../mock';\nimport jwt from 'jsonwebtoken';\nimport { Fragment, useState, useContext, useRef } from 'react'; // api url\n//if (localStorage.getItem('userlogin') !== null) {\n//}\n//localStorage.setItem('accessToken', 'dd5f3089-40c3-403d-af14-d0c228b05cb4')\n//localStorage.setItem('refreshToken', '7c4c1c50-3230-45bf-9eae-c9b2e401c767')\n// ! These two secrets shall be in .env file and not in any other file\n\nvar jwtConfig = {\n  secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\n  refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\n  expireTime: '10m',\n  refreshTokenExpireTime: '10m'\n};\nmock.onPost('/jwt/login').reply(function (request) {\n  var _JSON$parse = JSON.parse(request.data),\n      email = _JSON$parse.email,\n      password = _JSON$parse.password;\n\n  var error = {\n    email: ['Something went wrong']\n  }; //  const data = JSON.parse(localStorage.getItem('userlogin'))\n\n  var CryptoJS = require(\"crypto-js\");\n\n  var data = JSON.parse(CryptoJS.AES.decrypt(localStorage.getItem('encrypteddata'), 'encryptionkeysetbyyatinonsep2022').toString(CryptoJS.enc.Utf8)); // alert(\"testing\")\n\n  var user = data.users.find(function (u) {\n    return u.email === email && u.password === password;\n  });\n\n  if (user) {\n    try {\n      var accessToken = jwt.sign({\n        id: user.id\n      }, jwtConfig.secret, {\n        expiresIn: jwtConfig.expireTime\n      });\n      var refreshToken = jwt.sign({\n        id: user.id\n      }, jwtConfig.refreshTokenSecret, {\n        expiresIn: jwtConfig.refreshTokenExpireTime\n      });\n\n      var userData = _objectSpread({}, user);\n\n      delete userData.password;\n      var response = {\n        userData: userData,\n        accessToken: accessToken,\n        refreshToken: refreshToken\n      };\n      return [200, response];\n    } catch (e) {\n      error = e;\n    }\n  } else {\n    error = {\n      email: ['Email or Password is Invalid']\n    };\n  }\n\n  return [400, {\n    error: error\n  }];\n});\nmock.onPost('/jwt/register').reply(function (request) {\n  if (request.data.length > 0) {\n    var _JSON$parse2 = JSON.parse(request.data),\n        email = _JSON$parse2.email,\n        password = _JSON$parse2.password,\n        username = _JSON$parse2.username;\n\n    var isEmailAlreadyInUse = data.users.find(function (user) {\n      return user.email === email;\n    });\n    var isUsernameAlreadyInUse = data.users.find(function (user) {\n      return user.username === username;\n    });\n    var error = {\n      email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\n      username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\n    };\n\n    if (!error.username && !error.email) {\n      var userData = {\n        email: email,\n        password: password,\n        username: username,\n        fullName: '',\n        avatar: null,\n        role: 'admin',\n        ability: [{\n          action: 'manage',\n          subject: 'all'\n        }]\n      }; // Add user id\n\n      var length = data.users.length;\n      var lastIndex = 0;\n\n      if (length) {\n        lastIndex = data.users[length - 1].id;\n      }\n\n      userData.id = lastIndex + 1;\n      data.users.push(userData);\n      var accessToken = jwt.sign({\n        id: userData.id\n      }, jwtConfig.secret, {\n        expiresIn: jwtConfig.expireTime\n      });\n      var user = Object.assign({}, userData);\n      delete user['password'];\n      var response = {\n        user: user,\n        accessToken: accessToken\n      };\n      return [200, response];\n    } else {\n      return [200, {\n        error: error\n      }];\n    }\n  }\n});\nmock.onPost('/jwt/refresh-token').reply(function (request) {\n  var _JSON$parse3 = JSON.parse(request.data),\n      refreshToken = _JSON$parse3.refreshToken;\n\n  try {\n    var _jwt$verify = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret),\n        id = _jwt$verify.id;\n\n    var userData = _objectSpread({}, data.users.find(function (user) {\n      return user.id === id;\n    }));\n\n    var newAccessToken = jwt.sign({\n      id: userData.id\n    }, jwtConfig.secret, {\n      expiresIn: jwtConfig.expiresIn\n    });\n    var newRefreshToken = jwt.sign({\n      id: userData.id\n    }, jwtConfig.refreshTokenSecret, {\n      expiresIn: jwtConfig.refreshTokenExpireTime\n    });\n    delete userData.password;\n    var response = {\n      userData: userData,\n      accessToken: newAccessToken,\n      refreshToken: newRefreshToken\n    };\n    return [200, response];\n  } catch (e) {\n    var error = 'Invalid refresh token';\n    return [401, {\n      error: error\n    }];\n  }\n});","map":{"version":3,"sources":["C:/Users/nsahi/OneDrive/Documents/cyber_media/full-version/full-version/src/@fake-db/jwt/index.js"],"names":["mock","jwt","Fragment","useState","useContext","useRef","jwtConfig","secret","refreshTokenSecret","expireTime","refreshTokenExpireTime","onPost","reply","request","JSON","parse","data","email","password","error","CryptoJS","require","AES","decrypt","localStorage","getItem","toString","enc","Utf8","user","users","find","u","accessToken","sign","id","expiresIn","refreshToken","userData","response","e","length","username","isEmailAlreadyInUse","isUsernameAlreadyInUse","fullName","avatar","role","ability","action","subject","lastIndex","push","Object","assign","verify","newAccessToken","newRefreshToken"],"mappings":"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","sourcesContent":["// import mock from '../mock'\r\n// import jwt from 'jsonwebtoken'\r\n// import { Fragment, useState, useContext, useRef } from 'react'\r\n// // api url\r\n// const api_url = \"https://srvr1px.cyberads.io/cmgalaxy_users/?user_name=testing&password=Gemsbschool\"\r\n  \r\n// // Defining async function\r\n// async function getapi(url) {\r\n    \r\n//     // Storing response\r\n//     const response = await fetch(url)\r\n//     // Storing data in form of JSON\r\n//     const data1 = await response.json()\r\n//     console.log(data1)\r\n//     localStorage.setItem('userlogin', JSON.stringify(data1))\r\n\r\n// }\r\n// // Calling that async function\r\n// getapi(api_url)\r\n\r\n// // ! These two secrets shall be in .env file and not in any other file\r\n// const jwtConfig = {\r\n//   secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\r\n//   refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\r\n//   expireTime: '30m',\r\n//   refreshTokenExpireTime: '30m'\r\n// }\r\n\r\n// mock.onPost('/jwt/login').reply(request => {\r\n//   const { email, password } = JSON.parse(request.data)\r\n\r\n//   let error = {\r\n//     email: ['Something went wrong']\r\n//   }\r\n\r\n//   const user = data.users.find(u => u.email === email && u.password === password)\r\n\r\n//   if (user) {\r\n//     try {\r\n//       const accessToken = jwt.sign({ id: user.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n//       const refreshToken = jwt.sign({ id: user.id }, jwtConfig.refreshTokenSecret, {\r\n//         expiresIn: jwtConfig.refreshTokenExpireTime\r\n//       })\r\n\r\n//       const userData = { ...user }\r\n\r\n//       delete userData.password\r\n\r\n//       const response = {\r\n//         userData,\r\n//         accessToken,\r\n//         refreshToken\r\n//       }\r\n\r\n//       return [200, response]\r\n//     } catch (e) {\r\n//       error = e\r\n//     }\r\n//   } else {\r\n//     error = {\r\n//       email: ['Email or Password is Invalid']\r\n//     }\r\n//   }\r\n\r\n//   return [400, { error }]\r\n// })\r\n\r\n// mock.onPost('/jwt/register').reply(request => {\r\n//   if (request.data.length > 0) {\r\n//     const { email, password, username } = JSON.parse(request.data)\r\n//     const data = JSON.parse(localStorage.getItem('userlogin'))\r\n//     const isEmailAlreadyInUse = data.users.find(user => user.email === email)\r\n//     const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\r\n//     const error = {\r\n//       email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\r\n//       username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\r\n//     }\r\n\r\n//     if (!error.username && !error.email) {\r\n//       const userData = {\r\n//         email,\r\n//         password,\r\n//         username,\r\n//         fullName: '',\r\n//         avatar: null,\r\n//         role: 'admin',\r\n//         ability: [\r\n//           {\r\n//             action: 'manage',\r\n//             subject: 'all'\r\n//           }\r\n//         ]\r\n//       }\r\n\r\n//       // Add user id\r\n//       const length = data.users.length\r\n//       let lastIndex = 0\r\n//       if (length) {\r\n//         lastIndex = data.users[length - 1].id\r\n//       }\r\n//       userData.id = lastIndex + 1\r\n\r\n//       data.users.push(userData)\r\n\r\n//       const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n\r\n//       const user = Object.assign({}, userData)\r\n//       delete user['password']\r\n//       const response = { user, accessToken }\r\n\r\n//       return [200, response]\r\n//     } else {\r\n//       return [200, { error }]\r\n//     }\r\n//   }\r\n// })\r\n\r\n// mock.onPost('/jwt/refresh-token').reply(request => {\r\n//   const { refreshToken } = JSON.parse(request.data)\r\n\r\n//   try {\r\n//     const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\r\n\r\n//     const userData = { ...data.users.find(user => user.id === id) }\r\n\r\n//     const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\r\n//     const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\r\n//       expiresIn: jwtConfig.refreshTokenExpireTime\r\n//     })\r\n\r\n//     delete userData.password\r\n//     const response = {\r\n//       userData,\r\n//       accessToken: newAccessToken,\r\n//       refreshToken: newRefreshToken\r\n//     }\r\n\r\n//     return [200, response]\r\n//   } catch (e) {\r\n//     const error = 'Invalid refresh token'\r\n//     return [401, { error }]\r\n//   }\r\n// })\r\nimport mock from '../mock'\r\nimport jwt from 'jsonwebtoken'\r\nimport { Fragment, useState, useContext, useRef } from 'react'\r\n\r\n// api url\r\n//if (localStorage.getItem('userlogin') !== null) {\r\n\r\n//}\r\n//localStorage.setItem('accessToken', 'dd5f3089-40c3-403d-af14-d0c228b05cb4')\r\n//localStorage.setItem('refreshToken', '7c4c1c50-3230-45bf-9eae-c9b2e401c767')\r\n// ! These two secrets shall be in .env file and not in any other file\r\nconst jwtConfig = {\r\n  secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\r\n  refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\r\n  expireTime: '10m',\r\n  refreshTokenExpireTime: '10m'\r\n}\r\n\r\nmock.onPost('/jwt/login').reply(request => {\r\n  const { email, password } = JSON.parse(request.data)\r\n\r\n  let error = {\r\n    email: ['Something went wrong']\r\n  }\r\n\r\n//  const data = JSON.parse(localStorage.getItem('userlogin'))\r\nconst CryptoJS = require(\"crypto-js\")\r\n const data = JSON.parse((CryptoJS.AES.decrypt((localStorage.getItem('encrypteddata')), 'encryptionkeysetbyyatinonsep2022')).toString(CryptoJS.enc.Utf8))\r\n\r\n  // alert(\"testing\")\r\n  const user = data.users.find(u => u.email === email && u.password === password)\r\n\r\n  if (user) {\r\n    try {\r\n      const accessToken = jwt.sign({ id: user.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n      const refreshToken = jwt.sign({ id: user.id }, jwtConfig.refreshTokenSecret, {\r\n        expiresIn: jwtConfig.refreshTokenExpireTime\r\n      })\r\n\r\n      const userData = { ...user }\r\n\r\n      delete userData.password\r\n\r\n      const response = {\r\n        userData,\r\n        accessToken,\r\n        refreshToken\r\n      }\r\n\r\n      return [200, response]\r\n    } catch (e) {\r\n      error = e\r\n    }\r\n  } else {\r\n    error = {\r\n      email: ['Email or Password is Invalid']\r\n    }\r\n  }\r\n\r\n  return [400, { error }]\r\n})\r\n\r\nmock.onPost('/jwt/register').reply(request => {\r\n  if (request.data.length > 0) {\r\n    const { email, password, username } = JSON.parse(request.data)\r\n    const isEmailAlreadyInUse = data.users.find(user => user.email === email)\r\n    const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\r\n    const error = {\r\n      email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\r\n      username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\r\n    }\r\n\r\n    if (!error.username && !error.email) {\r\n      const userData = {\r\n        email,\r\n        password,\r\n        username,\r\n        fullName: '',\r\n        avatar: null,\r\n        role: 'admin',\r\n        ability: [\r\n          {\r\n            action: 'manage',\r\n            subject: 'all'\r\n          }\r\n        ]\r\n      }\r\n\r\n      // Add user id\r\n      const length = data.users.length\r\n      let lastIndex = 0\r\n      if (length) {\r\n        lastIndex = data.users[length - 1].id\r\n      }\r\n      userData.id = lastIndex + 1\r\n\r\n      data.users.push(userData)\r\n\r\n      const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\r\n\r\n      const user = Object.assign({}, userData)\r\n      delete user['password']\r\n      const response = { user, accessToken }\r\n\r\n      return [200, response]\r\n    } else {\r\n      return [200, { error }]\r\n    }\r\n  }\r\n})\r\n\r\nmock.onPost('/jwt/refresh-token').reply(request => {\r\n  const { refreshToken } = JSON.parse(request.data)\r\n\r\n  try {\r\n    const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\r\n\r\n    const userData = { ...data.users.find(user => user.id === id) }\r\n\r\n    const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\r\n    const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\r\n      expiresIn: jwtConfig.refreshTokenExpireTime\r\n    })\r\n\r\n    delete userData.password\r\n    const response = {\r\n      userData,\r\n      accessToken: newAccessToken,\r\n      refreshToken: newRefreshToken\r\n    }\r\n\r\n    return [200, response]\r\n  } catch (e) {\r\n    const error = 'Invalid refresh token'\r\n    return [401, { error }]\r\n  }\r\n})\r\n"]},"metadata":{},"sourceType":"module"}