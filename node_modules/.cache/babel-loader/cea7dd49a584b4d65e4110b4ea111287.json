{"ast":null,"code":"/**\r\n * @hidden\r\n *\r\n * Render the svg <path> element.\r\n *\r\n * @param points (array) Represents the points coordinates as an array of tuples.\r\n * @param command (function) The command that is used (bezierCommand, lineCommand).\r\n *      @param point (array) [x,y] Represents the current point coordinates.\r\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\r\n *      @param a (array) Represents the complete array of points coordinates.\r\n *      @output (string) a svg path command.\r\n * @output (string) a Svg <path> element\r\n */\nexport var svgPath = function svgPath(points, command) {\n  if (points.length === 0) {\n    return '';\n  } // build the d attributes by looping over the points\n\n\n  var d = points.reduce(function (acc, point, i, a) {\n    return i === 0 ? // if first point\n    \"M \".concat(point[0], \",\").concat(point[1]) : // else\n    \"\".concat(acc, \" \").concat(command(point, i, a));\n  }, '');\n  return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\");\n};\n/**\r\n * @hidden\r\n *\r\n * Returns the properties of a line.\r\n *\r\n * @param pointA (array) [x,y] Represents the start point coordinates.\r\n * @param pointB (array) [x,y] Represents the end point coordinates.\r\n * @output (object) { length: (integer), angle: (integer) }\r\n */\n\nexport var line = function line(pointA, pointB) {\n  var lengthX = pointB[0] - pointA[0];\n  var lengthY = pointB[1] - pointA[1];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n/**\r\n * @hidden\r\n *\r\n * Create a function to calculate the position of the control point.\r\n *\r\n * @param lineCalc (function) Represents the line function.\r\n *      @param pointA (array) [x,y] Represents the start point coordinates.\r\n *      @param pointB (array) [x,y] Represents the end point coordinates.\r\n *      @output (object) { length: (integer), angle: (integer) }\r\n * @output (function) closure.\r\n *      @param current (array) [x, y] Represents the current point coordinates.\r\n *      @param previous (array) [x, y] Represents the previous point coordinates.\r\n *      @param next (array) [x, y] ]Represents the next point coordinates.\r\n *      @param reverse (boolean, optional) Sets the direction.\r\n *      @output (array) [x, y] coordinates of a control point.\r\n */\n\nexport var controlPoint = function controlPoint(lineCalc) {\n  return function (current, previous, next, reverse) {\n    // when 'current' is the first or last point of the array\n    // 'previous' and 'next' are undefined \n    // replace with 'current'\n    var p = previous || current;\n    var n = next || current;\n    var smooth = 0.1; // properties of the line between previous and next \n\n    var l = lineCalc(p, n); // If is end-control-point, add PI to the angle to go backward\n\n    var angle = l.angle + (reverse ? Math.PI : 0);\n    var length = l.length * smooth; // The control point position is relative to the current point\n\n    var x = current[0] + Math.cos(angle) * length;\n    var y = current[1] + Math.sin(angle) * length;\n    return [x, y];\n  };\n};\n/**\r\n * @hidden\r\n *\r\n * Create a function to calculate a bezier curve command.\r\n *\r\n * @param controlPointCalc (function) Represents the controlPoint function.\r\n *      @param current (array) [x, y] Represents the current point coordinates.\r\n *      @param previous (array) [x, y] Represents the previous point coordinates.\r\n *      @param next (array) [x, y] ]Represents the next point coordinates.\r\n *      @param reverse (boolean, optional) Sets the direction.\r\n *      @output (array) [x, y] coordinates of a control point.\r\n * @output (function) closure.\r\n *      @param point (array) [x,y] Represents the current point coordinates.\r\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\r\n *      @param a (array) Represents the complete array of points coordinates.\r\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\r\n */\n\nexport var bezierCommand = function bezierCommand(controlPointCalc) {\n  return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point),\n        cpsX = _a[0],\n        cpsY = _a[1]; // end control point\n\n\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true),\n        cpeX = _b[0],\n        cpeY = _b[1];\n\n    return \"C \".concat(cpsX, \",\").concat(cpsY, \" \").concat(cpeX, \",\").concat(cpeY, \" \").concat(point[0], \",\").concat(point[1]);\n  };\n};","map":{"version":3,"sources":["C:/Users/nsahi/OneDrive/Documents/cyber_media/cm_galaxy/node_modules/@progress/kendo-react-inputs/dist/es/colors/utils/svg-calc.js"],"names":["svgPath","points","command","length","d","reduce","acc","point","i","a","concat","line","pointA","pointB","lengthX","lengthY","Math","sqrt","pow","angle","atan2","controlPoint","lineCalc","current","previous","next","reverse","p","n","smooth","l","PI","x","cos","y","sin","bezierCommand","controlPointCalc","_a","cpsX","cpsY","_b","cpeX","cpeY"],"mappings":"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","sourcesContent":["/**\r\n * @hidden\r\n *\r\n * Render the svg <path> element.\r\n *\r\n * @param points (array) Represents the points coordinates as an array of tuples.\r\n * @param command (function) The command that is used (bezierCommand, lineCommand).\r\n *      @param point (array) [x,y] Represents the current point coordinates.\r\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\r\n *      @param a (array) Represents the complete array of points coordinates.\r\n *      @output (string) a svg path command.\r\n * @output (string) a Svg <path> element\r\n */\r\nexport var svgPath = function (points, command) {\r\n    if (points.length === 0) {\r\n        return '';\r\n    }\r\n    // build the d attributes by looping over the points\r\n    var d = points.reduce(function (acc, point, i, a) {\r\n        return i === 0 ?\r\n            // if first point\r\n            \"M \".concat(point[0], \",\").concat(point[1]) :\r\n            // else\r\n            \"\".concat(acc, \" \").concat(command(point, i, a));\r\n    }, '');\r\n    return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\");\r\n};\r\n/**\r\n * @hidden\r\n *\r\n * Returns the properties of a line.\r\n *\r\n * @param pointA (array) [x,y] Represents the start point coordinates.\r\n * @param pointB (array) [x,y] Represents the end point coordinates.\r\n * @output (object) { length: (integer), angle: (integer) }\r\n */\r\nexport var line = function (pointA, pointB) {\r\n    var lengthX = pointB[0] - pointA[0];\r\n    var lengthY = pointB[1] - pointA[1];\r\n    return {\r\n        length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\r\n        angle: Math.atan2(lengthY, lengthX)\r\n    };\r\n};\r\n/**\r\n * @hidden\r\n *\r\n * Create a function to calculate the position of the control point.\r\n *\r\n * @param lineCalc (function) Represents the line function.\r\n *      @param pointA (array) [x,y] Represents the start point coordinates.\r\n *      @param pointB (array) [x,y] Represents the end point coordinates.\r\n *      @output (object) { length: (integer), angle: (integer) }\r\n * @output (function) closure.\r\n *      @param current (array) [x, y] Represents the current point coordinates.\r\n *      @param previous (array) [x, y] Represents the previous point coordinates.\r\n *      @param next (array) [x, y] ]Represents the next point coordinates.\r\n *      @param reverse (boolean, optional) Sets the direction.\r\n *      @output (array) [x, y] coordinates of a control point.\r\n */\r\nexport var controlPoint = function (lineCalc) {\r\n    return function (current, previous, next, reverse) {\r\n        // when 'current' is the first or last point of the array\r\n        // 'previous' and 'next' are undefined \r\n        // replace with 'current'\r\n        var p = previous || current;\r\n        var n = next || current;\r\n        var smooth = 0.1;\r\n        // properties of the line between previous and next \r\n        var l = lineCalc(p, n);\r\n        // If is end-control-point, add PI to the angle to go backward\r\n        var angle = l.angle + (reverse ? Math.PI : 0);\r\n        var length = l.length * smooth;\r\n        // The control point position is relative to the current point\r\n        var x = current[0] + Math.cos(angle) * length;\r\n        var y = current[1] + Math.sin(angle) * length;\r\n        return [x, y];\r\n    };\r\n};\r\n/**\r\n * @hidden\r\n *\r\n * Create a function to calculate a bezier curve command.\r\n *\r\n * @param controlPointCalc (function) Represents the controlPoint function.\r\n *      @param current (array) [x, y] Represents the current point coordinates.\r\n *      @param previous (array) [x, y] Represents the previous point coordinates.\r\n *      @param next (array) [x, y] ]Represents the next point coordinates.\r\n *      @param reverse (boolean, optional) Sets the direction.\r\n *      @output (array) [x, y] coordinates of a control point.\r\n * @output (function) closure.\r\n *      @param point (array) [x,y] Represents the current point coordinates.\r\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\r\n *      @param a (array) Represents the complete array of points coordinates.\r\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\r\n */\r\nexport var bezierCommand = function (controlPointCalc) { return function (point, i, a) {\r\n    // start control point\r\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point), cpsX = _a[0], cpsY = _a[1];\r\n    // end control point\r\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true), cpeX = _b[0], cpeY = _b[1];\r\n    return \"C \".concat(cpsX, \",\").concat(cpsY, \" \").concat(cpeX, \",\").concat(cpeY, \" \").concat(point[0], \",\").concat(point[1]);\r\n}; };\r\n"]},"metadata":{},"sourceType":"module"}